--
-- PostgreSQL database dump
--

-- Dumped from database version 16.0 (Debian 16.0-1.pgdg120+1)
-- Dumped by pg_dump version 16.0 (Debian 16.0-1.pgdg120+1)

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

SET default_tablespace = '';

SET default_table_access_method = heap;

--
-- Name: foo; Type: TABLE; Schema: public; Owner: root
--

CREATE TABLE public.foo (
    fooid integer,
    foosubid integer,
    fooname text
);


ALTER TABLE public.foo OWNER TO root;

--
-- Name: getfoonext(); Type: FUNCTION; Schema: public; Owner: root
--

CREATE FUNCTION public.getfoonext() RETURNS SETOF public.foo
    LANGUAGE plpgsql
    AS $$
declare
    r foo%rowtype;
    stack text;
begin
    GET DIAGNOSTICS stack = PG_CONTEXT;
    RAISE NOTICE E'--- CALL STACK ---\n%', stack;
    for r in select * from foo where fooid > 0
    loop
        return next r;
    end loop;
    return;
end
$$;


ALTER FUNCTION public.getfoonext() OWNER TO root;

--
-- Name: getfooquery(); Type: FUNCTION; Schema: public; Owner: root
--

CREATE FUNCTION public.getfooquery() RETURNS SETOF public.foo
    LANGUAGE plpgsql
    AS $$
declare r foo%rowtype;
begin
    return query select * from foo where fooid > 0;
    return;
end
$$;


ALTER FUNCTION public.getfooquery() OWNER TO root;

--
-- Name: is_fib(integer); Type: FUNCTION; Schema: public; Owner: root
--

CREATE FUNCTION public.is_fib(i integer) RETURNS boolean
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
DECLARE
 a integer := 5*i*i+4;
 b integer := 5*i*i-4;
 asq integer;
 bsq integer;
BEGIN
IF i <= 0 THEN RETURN false; END IF;
 asq = sqrt(a)::int;
 bsq = sqrt(b)::int;
 RETURN asq*asq=a OR bsq*bsq=b;
end
$$;


ALTER FUNCTION public.is_fib(i integer) OWNER TO root;

--
-- Name: notify_event(); Type: FUNCTION; Schema: public; Owner: root
--

CREATE FUNCTION public.notify_event() RETURNS trigger
    LANGUAGE plpgsql
    AS $$

    DECLARE
        data json;
        notification json;

    BEGIN

        -- Convert the old or new row to JSON, based on the kind of action.
        -- Action = DELETE?             -> OLD row
        -- Action = INSERT or UPDATE?   -> NEW row
        IF (TG_OP = 'DELETE') THEN
            data = row_to_json(OLD);
        ELSE
            data = row_to_json(NEW);
        END IF;

        -- Contruct the notification as a JSON string.
        notification = json_build_object(
                          'table',TG_TABLE_NAME,
                          'action', TG_OP,
                          'data', data);


        -- Execute pg_notify(channel, notification)
        PERFORM pg_notify('events',notification::text);

        -- Result is ignored since this is an AFTER trigger
        RETURN NULL;
    END;

$$;


ALTER FUNCTION public.notify_event() OWNER TO root;

--
-- Name: shadow(); Type: FUNCTION; Schema: public; Owner: root
--

CREATE FUNCTION public.shadow() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $_$
DECLARE
   shadow_schema TEXT;
   shadow_table TEXT;
BEGIN
   IF (TG_NARGS <> 2) THEN
      RAISE EXCEPTION 'Incorrect number of arguments for shadow_function(schema, table): %', TG_NARGS;
   END IF;
    shadow_schema = TG_ARGV[0];
    shadow_table = TG_ARGV[1];
   IF TG_OP = 'INSERT' THEN
      EXECUTE 'INSERT INTO ' || quote_ident(shadow_table) || ' SELECT $1.*, current_user, $2 , now()' USING NEW, TG_OP;
      RETURN NEW;
   ELSIF TG_OP = 'UPDATE' THEN
      EXECUTE 'INSERT INTO ' || quote_ident(shadow_table) || ' SELECT $1.*, current_user, $2 , now()' USING NEW, TG_OP;
      RETURN NEW;
   ELSIF TG_OP = 'DELETE' THEN
      EXECUTE 'INSERT INTO ' || quote_ident(shadow_table) || ' SELECT $1.*, current_user, $2 , now()' USING OLD, TG_OP;
      RETURN OLD;
   ELSIF TG_OP = 'TRUNCATE' THEN
-- insert every row that was present
        -- EXECUTE 'INSERT INTO ' || quote_ident(shadow_table) || ' SELECT a.*, current_user, $1, now() FROM ' || quote_ident(TG_TABLE_NAME) || ' a' USING TG_OP;
-- insert just one row
        EXECUTE 'INSERT INTO ' || quote_ident(shadow_table) || ' (user_name, action, action_time) VALUES (current_user, $1 , now())' USING TG_OP;
      RETURN NULL;
   END IF;
END;
$_$;


ALTER FUNCTION public.shadow() OWNER TO root;

--
-- Name: dndclasses; Type: TABLE; Schema: public; Owner: root
--

CREATE TABLE public.dndclasses (
    id integer NOT NULL,
    parent_id integer,
    name text
);


ALTER TABLE public.dndclasses OWNER TO root;

--
-- Name: dndclasses_id_seq; Type: SEQUENCE; Schema: public; Owner: root
--

ALTER TABLE public.dndclasses ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.dndclasses_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: onlyfib; Type: TABLE; Schema: public; Owner: root
--

CREATE TABLE public.onlyfib (
    i integer,
    CONSTRAINT onlyfib_i_check CHECK (public.is_fib(i))
);


ALTER TABLE public.onlyfib OWNER TO root;

--
-- Name: payroll; Type: TABLE; Schema: public; Owner: root
--

CREATE TABLE public.payroll (
    emp_no integer,
    emp_name character varying(20) NOT NULL,
    dept_name character varying(15) NOT NULL,
    salary_amt numeric(8,2) NOT NULL,
    CONSTRAINT payroll_salary_amt_check CHECK ((salary_amt > 0.00))
);


ALTER TABLE public.payroll OWNER TO root;

--
-- Name: products; Type: TABLE; Schema: public; Owner: root
--

CREATE TABLE public.products (
    id integer NOT NULL,
    name text,
    quantity double precision
);


ALTER TABLE public.products OWNER TO root;

--
-- Name: products_citus; Type: TABLE; Schema: public; Owner: root
--

CREATE TABLE public.products_citus (
    product_no integer,
    name text,
    price numeric,
    sale_price numeric,
    CONSTRAINT products_citus_check CHECK ((price > sale_price)),
    CONSTRAINT products_citus_price_check CHECK ((price > (0)::numeric)),
    CONSTRAINT products_citus_sale_price_check CHECK ((sale_price > (0)::numeric))
);


ALTER TABLE public.products_citus OWNER TO root;

--
-- Name: products_id_seq; Type: SEQUENCE; Schema: public; Owner: root
--

CREATE SEQUENCE public.products_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE public.products_id_seq OWNER TO root;

--
-- Name: products_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: root
--

ALTER SEQUENCE public.products_id_seq OWNED BY public.products.id;


--
-- Name: schema_migrations; Type: TABLE; Schema: public; Owner: root
--

CREATE TABLE public.schema_migrations (
    version character varying(128) NOT NULL
);


ALTER TABLE public.schema_migrations OWNER TO root;

--
-- Name: table1; Type: TABLE; Schema: public; Owner: root
--

CREATE TABLE public.table1 (
    key integer NOT NULL,
    value integer,
    value_type character varying
);


ALTER TABLE public.table1 OWNER TO root;

--
-- Name: table1_key_seq; Type: SEQUENCE; Schema: public; Owner: root
--

CREATE SEQUENCE public.table1_key_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE public.table1_key_seq OWNER TO root;

--
-- Name: table1_key_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: root
--

ALTER SEQUENCE public.table1_key_seq OWNED BY public.table1.key;


--
-- Name: table2; Type: TABLE; Schema: public; Owner: root
--

CREATE TABLE public.table2 (
    key integer NOT NULL,
    value integer,
    value_type character varying,
    user_name name,
    action character varying,
    action_time timestamp without time zone
);


ALTER TABLE public.table2 OWNER TO root;

--
-- Name: table2_key_seq; Type: SEQUENCE; Schema: public; Owner: root
--

CREATE SEQUENCE public.table2_key_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE public.table2_key_seq OWNER TO root;

--
-- Name: table2_key_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: root
--

ALTER SEQUENCE public.table2_key_seq OWNED BY public.table2.key;


--
-- Name: products id; Type: DEFAULT; Schema: public; Owner: root
--

ALTER TABLE ONLY public.products ALTER COLUMN id SET DEFAULT nextval('public.products_id_seq'::regclass);


--
-- Name: table1 key; Type: DEFAULT; Schema: public; Owner: root
--

ALTER TABLE ONLY public.table1 ALTER COLUMN key SET DEFAULT nextval('public.table1_key_seq'::regclass);


--
-- Name: table2 key; Type: DEFAULT; Schema: public; Owner: root
--

ALTER TABLE ONLY public.table2 ALTER COLUMN key SET DEFAULT nextval('public.table2_key_seq'::regclass);


--
-- Data for Name: dndclasses; Type: TABLE DATA; Schema: public; Owner: root
--

INSERT INTO public.dndclasses VALUES (1, NULL, 'Warrior');
INSERT INTO public.dndclasses VALUES (2, NULL, 'Wizard');
INSERT INTO public.dndclasses VALUES (3, NULL, 'Priest');
INSERT INTO public.dndclasses VALUES (4, NULL, 'Rogue');
INSERT INTO public.dndclasses VALUES (5, 1, 'Fighter');
INSERT INTO public.dndclasses VALUES (6, 1, 'Paladin');
INSERT INTO public.dndclasses VALUES (7, 1, 'Ranger');
INSERT INTO public.dndclasses VALUES (8, 2, 'Mage');
INSERT INTO public.dndclasses VALUES (9, 2, 'Specialist wizard');
INSERT INTO public.dndclasses VALUES (10, 3, 'Cleric');
INSERT INTO public.dndclasses VALUES (11, 3, 'Druid');
INSERT INTO public.dndclasses VALUES (12, 3, 'Priest of specific mythos');
INSERT INTO public.dndclasses VALUES (13, 4, 'Thief');
INSERT INTO public.dndclasses VALUES (14, 4, 'Bard');
INSERT INTO public.dndclasses VALUES (15, 13, 'Assassin');


--
-- Data for Name: foo; Type: TABLE DATA; Schema: public; Owner: root
--

INSERT INTO public.foo VALUES (1, 2, 'three');
INSERT INTO public.foo VALUES (4, 5, 'six');


--
-- Data for Name: onlyfib; Type: TABLE DATA; Schema: public; Owner: root
--

INSERT INTO public.onlyfib VALUES (5);
INSERT INTO public.onlyfib VALUES (8);


--
-- Data for Name: payroll; Type: TABLE DATA; Schema: public; Owner: root
--

INSERT INTO public.payroll VALUES (1, 'Mark Stone', 'Accounting', 16000.00);
INSERT INTO public.payroll VALUES (2, 'Maria Stone', 'Accounting', 13000.00);
INSERT INTO public.payroll VALUES (3, 'Geetha Singh', 'Accounting', 13000.00);
INSERT INTO public.payroll VALUES (4, 'Richard Hathaway', 'Accounting', 14000.00);
INSERT INTO public.payroll VALUES (5, 'Joseph Bastion', 'Accounting', 14000.00);
INSERT INTO public.payroll VALUES (6, 'Arthur Prince', 'Production', 12000.00);
INSERT INTO public.payroll VALUES (7, 'Adele Morse', 'Production', 13000.00);
INSERT INTO public.payroll VALUES (8, 'Sheamus O Kelly', 'Production', 24000.00);
INSERT INTO public.payroll VALUES (9, 'Sheilah Flask', 'Production', 24000.00);
INSERT INTO public.payroll VALUES (10, 'Brian James', 'Production', 16000.00);
INSERT INTO public.payroll VALUES (11, 'Adam Scott', 'Production', 16000.00);
INSERT INTO public.payroll VALUES (12, 'Maurice Moss', 'IT', 12000.00);
INSERT INTO public.payroll VALUES (13, 'Roy', 'IT', 12001.00);
INSERT INTO public.payroll VALUES (14, 'Jen Barber', 'IT', 28000.00);
INSERT INTO public.payroll VALUES (15, 'Richard Hammond', 'IT', 10000.00);
INSERT INTO public.payroll VALUES (16, 'James May', 'IT', 10000.00);
INSERT INTO public.payroll VALUES (18, 'Jeremy Clarkson', 'IT', 10000.00);
INSERT INTO public.payroll VALUES (17, 'John Doe', 'IT', 100000.00);


--
-- Data for Name: products; Type: TABLE DATA; Schema: public; Owner: root
--



--
-- Data for Name: products_citus; Type: TABLE DATA; Schema: public; Owner: root
--

INSERT INTO public.products_citus VALUES (1, 'product name', 10, 5);


--
-- Data for Name: schema_migrations; Type: TABLE DATA; Schema: public; Owner: root
--

INSERT INTO public.schema_migrations VALUES ('20240219182555');
INSERT INTO public.schema_migrations VALUES ('20240221212444');
INSERT INTO public.schema_migrations VALUES ('20240224084030');
INSERT INTO public.schema_migrations VALUES ('20240224164745');
INSERT INTO public.schema_migrations VALUES ('20240224212847');
INSERT INTO public.schema_migrations VALUES ('20240225152915');


--
-- Data for Name: table1; Type: TABLE DATA; Schema: public; Owner: root
--

INSERT INTO public.table1 VALUES (5, 30, 'meters');


--
-- Data for Name: table2; Type: TABLE DATA; Schema: public; Owner: root
--

INSERT INTO public.table2 VALUES (1, 30, 'meters', 'root', 'INSERT', '2024-02-25 22:01:31.150737');
INSERT INTO public.table2 VALUES (2, 10, 'inches', 'root', 'INSERT', '2024-02-25 22:01:31.150737');
INSERT INTO public.table2 VALUES (2, 20, 'inches', 'root', 'UPDATE', '2024-02-25 22:01:31.150737');
INSERT INTO public.table2 VALUES (2, 20, 'inches', 'root', 'DELETE', '2024-02-25 22:01:31.150737');
INSERT INTO public.table2 VALUES (3, 50, 'inches', 'root', 'INSERT', '2024-02-25 22:01:31.150737');
INSERT INTO public.table2 VALUES (1, NULL, NULL, 'root', 'TRUNCATE', '2024-02-25 22:01:31.150737');
INSERT INTO public.table2 VALUES (4, 50, 'inches', 'root', 'INSERT', '2024-02-25 22:01:31.150737');
INSERT INTO public.table2 VALUES (4, 50, 'inches', 'root', 'DELETE', '2024-02-25 22:01:31.150737');
INSERT INTO public.table2 VALUES (5, 30, 'meters', 'root', 'INSERT', '2024-02-25 22:01:31.150737');


--
-- Name: dndclasses_id_seq; Type: SEQUENCE SET; Schema: public; Owner: root
--

SELECT pg_catalog.setval('public.dndclasses_id_seq', 1, false);


--
-- Name: products_id_seq; Type: SEQUENCE SET; Schema: public; Owner: root
--

SELECT pg_catalog.setval('public.products_id_seq', 1, false);


--
-- Name: table1_key_seq; Type: SEQUENCE SET; Schema: public; Owner: root
--

SELECT pg_catalog.setval('public.table1_key_seq', 5, true);


--
-- Name: table2_key_seq; Type: SEQUENCE SET; Schema: public; Owner: root
--

SELECT pg_catalog.setval('public.table2_key_seq', 1, true);


--
-- Name: dndclasses dndclasses_pkey; Type: CONSTRAINT; Schema: public; Owner: root
--

ALTER TABLE ONLY public.dndclasses
    ADD CONSTRAINT dndclasses_pkey PRIMARY KEY (id);


--
-- Name: schema_migrations schema_migrations_pkey; Type: CONSTRAINT; Schema: public; Owner: root
--

ALTER TABLE ONLY public.schema_migrations
    ADD CONSTRAINT schema_migrations_pkey PRIMARY KEY (version);


--
-- Name: table1 table1_pkey; Type: CONSTRAINT; Schema: public; Owner: root
--

ALTER TABLE ONLY public.table1
    ADD CONSTRAINT table1_pkey PRIMARY KEY (key);


--
-- Name: products products_notify_event; Type: TRIGGER; Schema: public; Owner: root
--

CREATE TRIGGER products_notify_event AFTER INSERT OR DELETE OR UPDATE ON public.products FOR EACH ROW EXECUTE FUNCTION public.notify_event();


--
-- Name: table1 table1_tr; Type: TRIGGER; Schema: public; Owner: root
--

CREATE TRIGGER table1_tr BEFORE INSERT OR DELETE OR UPDATE ON public.table1 FOR EACH ROW EXECUTE FUNCTION public.shadow('mydb', 'table2');


--
-- Name: table1 table1_tr1; Type: TRIGGER; Schema: public; Owner: root
--

CREATE TRIGGER table1_tr1 BEFORE TRUNCATE ON public.table1 FOR EACH STATEMENT EXECUTE FUNCTION public.shadow('mydb', 'table2');


--
-- Name: dndclasses dndclasses_parent_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: root
--

ALTER TABLE ONLY public.dndclasses
    ADD CONSTRAINT dndclasses_parent_id_fkey FOREIGN KEY (parent_id) REFERENCES public.dndclasses(id);


--
-- PostgreSQL database dump complete
--

